#!/usr/bin/python
import subprocess
import sys
import tkinter as tk
import threading
import os

KEYWORDS = ["var", "print", "call", "jmp", "ret", "nop", "add", "sub", "mul", "div", "inp","cmp","gj","lj","ej","obj","flip","hazbrow"]
def is_number(s: str) -> bool:
    try:
        float(s)
        return True
    except ValueError:
        return False


def tokenizer(s: str):
    lines = s.split("\n")
    tokens = []
    for line in lines:
        tokens.extend(subtok(line))
    return tokens


def subtok(s: str) -> list[str]:
    parts = []
    current = []
    in_quotes = False

    i = 0
    while i < len(s):
        c = s[i]

        if c == '"':
            in_quotes = not in_quotes
            current.append(c)
        elif c == ' ' and not in_quotes:
            if current:
                parts.append(''.join(current))
                current = []
        else:
            current.append(c)
        i += 1

    if current:
        parts.append(''.join(current))

    return parts


def identall(tokens):
    i = 0
    arry = []
    while i < len(tokens):
        arry.append(identify(tokens[i]))
        i = i + 1
    return arry  


def identify(token):
    if token[-1] == ":":
        return ("Label", token[:-1])
    if token[0] == '"' and token[-1] == '"':
        return ("String", token[1:-1])  # strip quotes here
    elif is_number(token):
        return ("Number", token)
    elif token in KEYWORDS:
        return ("Keyword", token)
    elif token == "EOF":
        return ("EOF", None)
    else:
        return ("Identifier", token)



def ParseStart(code):
        return identall(tokenizer(code))

def lexer(lexcode):
    gt = lt = eq = False
    vars = {}
    textobj = {}
    intray = []
    labels = {}
    retpos = 0
    if lexcode[0] != ("Keyword","hazbrow"):
        text = "sorry but this site is not a hazbrow site..."
        root.after(0, lambda t=text: text_widget.insert("end", t))
        while True:
            retpos = retpos - 0

    # --- Pass 1: collect labels ---
    for idx, (title, val) in enumerate(lexcode):
        if title == "Label":
            labels[val] = idx

    # --- Pass 2: execute ---
    i = 0
    while i < len(lexcode):
        title, val = lexcode[i]

        # ----------------------------
        # Handle Keywords / Instructions
        # ----------------------------
        if title == "Keyword":

            # --- no operation ---
            if val == "nop":
                pass

            # --- print ---
            elif val == "print" and i + 1 < len(lexcode):
                next_title, next_val = lexcode[i + 1]
                if next_title == "String":
                    print(next_val)
                elif next_title == "Identifier":
                    print(vars.get(next_val, f"Undefined variable: {next_val}"))
                else:
                    print("Syntax error: 'print' expects a string or variable")
                i += 1

            # --- cmp ---
            elif val == "cmp" and i + 2 < len(lexcode):
                nt, nv = lexcode[i + 1]
                nnt, nnv = lexcode[i + 2]

                left = float(vars[nv]) if nt == "Identifier" else float(nv)
                right = float(vars[nnv]) if nnt == "Identifier" else float(nnv)

                gt, lt, eq = left > right, left < right, left == right
                i += 2

            # --- var assignment ---
            elif val == "var" and i + 2 < len(lexcode):
                name_title, name_val = lexcode[i + 1]
                value_title, value_val = lexcode[i + 2]

                if name_title != "Identifier":
                    print("Syntax error: expected variable name after 'var'")
                else:
                    if value_title == "String":
                        vars[name_val] = value_val
                    elif value_title == "Number":
                        vars[name_val] = float(value_val)
                    elif value_title == "Identifier":
                        vars[name_val] = vars.get(value_val, 0)
                    else:
                        print(f"Syntax error: unexpected token '{value_val}'")
                i += 2

            # --- arithmetic operations ---
            elif val in ("add", "sub", "mul", "div") and i + 2 < len(lexcode):
                name_title, name_val = lexcode[i + 1]
                value_title, value_val = lexcode[i + 2]

                if name_title != "Identifier":
                    print(f"Syntax error: expected variable name after '{val}'")
                else:
                    a = float(vars.get(name_val, 0))
                    b = float(vars.get(value_val, 0)) if value_title == "Identifier" else float(value_val)

                    if val == "add":
                        vars[name_val] = a + b
                    elif val == "sub":
                        vars[name_val] = a - b
                    elif val == "mul":
                        vars[name_val] = a * b
                    elif val == "div":
                        vars[name_val] = a / b
                i += 2

            # --- input ---
            elif val == "inp" and i + 2 < len(lexcode):
                next_title, next_val = lexcode[i + 1]
                nnext_title, nnext_val = lexcode[i + 2]
                if next_title == "Identifier":
                    if nnext_title == "Number" and float(nnext_val) < 1:
                        vars[next_val] = input()
                    else:
                        vars[next_val] = float(input())
                else:
                    print("Syntax error: expected variable name for input")
                    quit()
                i += 2

            # --- call ---
            elif val == "call" and i + 1 < len(lexcode):
                next_title, next_val = lexcode[i + 1]
                retpos = i + 2
                if next_title == "String":
                    i = labels[next_val]
                elif next_title == "Identifier":
                    i = labels.get(vars.get(next_val, ""), i)
                else:
                    print("Syntax error: 'call' expects a label name")
                    break
                continue  # skip i += 1

            # --- unconditional jump ---
            elif val == "jmp" and i + 1 < len(lexcode):
                next_title, next_val = lexcode[i + 1]
                if next_title == "String":
                    i = labels[next_val]
                elif next_title == "Identifier":
                    i = labels.get(vars.get(next_val, ""), i)
                else:
                    print("Syntax error: 'jmp' expects a label name")
                    break
                continue  # skip i += 1

            # --- return ---
            elif val == "ret":
                i = retpos
                continue

            # --- conditional jumps ---
            elif val == "gj" and i + 1 < len(lexcode) and gt:
                next_title, next_val = lexcode[i + 1]
                if next_title == "String":
                    i = labels[next_val]
                elif next_title == "Identifier":
                    i = labels.get(vars.get(next_val, ""), i)
                continue

            elif val == "lj" and i + 1 < len(lexcode) and lt:
                next_title, next_val = lexcode[i + 1]
                if next_title == "String":
                    i = labels[next_val]
                elif next_title == "Identifier":
                    i = labels.get(vars.get(next_val, ""), i)
                continue

            elif val == "ej" and i + 1 < len(lexcode) and eq:
                next_title, next_val = lexcode[i + 1]
                if next_title == "String":
                    i = labels[next_val]
                elif next_title == "Identifier":
                    i = labels.get(vars.get(next_val, ""), i)
                continue
            elif val == "obj":
                next_title, next_val = lexcode[i + 1]
                nnext_title, nnext_val = lexcode[i + 2]
                nnnext_title, nnnext_val = lexcode[i + 3]
                if next_title != "String" or nnext_title != "String" or nnnext_title != "String":
                    break
                if next_val == "text":
                    #text syntax
                    #(data)
                    #intray
                    #(ident)

                    intray.append(nnext_val)
                    textobj[nnext_val] = nnnext_val

                    pass
                i = i + 3
            elif val == "flip":
                arrylen = len(intray)
                k = 0
                while k < arrylen:
                    crrntitem = intray[k]
                    text = textobj[crrntitem]
                    #textarry = list(text)
                    #root.after(0, lambda t=text: text_widget.insert("end", t + "\n"))
                    text = text.replace("\\n", "\n")
                    root.after(0, lambda t=text: text_widget.insert("end", t))
                    k = k + 1

        # ----------------------------
        # Handle EOF
        # ----------------------------
        elif title == "EOF":
            break

        i += 1  # increment i if no jump/continue
        #print(f'text: {textobj}')

def on_close():
    os._exit(0)

def init():
    global root, text_widget
    root = tk.Tk()
    root.title("hbrow")
    text_widget = tk.Text(root, wrap="word")
    text_widget.pack(expand=True, fill="both")
    root.configure(background="white")
    root.minsize(200, 200)
    root.maxsize(500, 500)
    root.geometry("300x300+50+50")
    root.protocol("WM_DELETE_WINDOW", on_close)
    root.mainloop()

def fetch(url):

    threading.Thread(target=init, daemon=True).start()
    return (subprocess.check_output(['curl','-s', f'{url}/index.ypp'])).decode()



lexer(ParseStart(fetch(sys.argv[1])))